buildscript {
    dependencies {
        classpath group: 'net.minecraftforge.gradle', name: 'ForgeGradle', version: '5.1.+', changing: true
    }
}

plugins {
    id 'java'
    id 'eclipse'
    id 'org.cadixdev.licenser' version '0.6.1'
    id 'io.freefair.lombok' version '6.5.0.2'
    id 'wtf.gofancy.fancygradle' version '1.+'
}

apply plugin: 'net.minecraftforge.gradle'
java.toolchain.languageVersion = JavaLanguageVersion.of(8)

version = "${mod_version}"
group = "${mod_group}"
archivesBaseName = "${mod_archivesBaseName}"

java {
    withJavadocJar()
}

compileJava {
    options.encoding = "UTF-8"
}

configurations {
    implementation.extendsFrom mod
    compileOnly.extendsFrom modCompile
    runtimeOnly.extendsFrom runOnly
}

repositories {
    mavenCentral()
    maven {
        name 'galacticraft'
        url 'https://repo.galacticraft.net/repository/maven' 
    }
}

dependencies {
    minecraft "net.minecraftforge:forge:${mc_version}-${forge_version}"
    mod fg.deobf('dev.galacticraft:galacticraft-legacy:4.0.3')
}

minecraft {
    mappings channel: "${mapping_channel}", version: "${mapping_version}"

    accessTransformer = file('src/main/resources/META-INF/accesstransformer.cfg')

    runs {
        client {
            workingDirectory project.file('run')
            property 'forge.logging.markers', 'REGISTRIES'
            property 'forge.logging.console.level', 'debug'
            if (project.hasProperty('uuid'))
                args '--uuid', project.getProperty('uuid')
            if (project.hasProperty('username'))
                args '--username', project.getProperty('username')
        }
        server {
            workingDirectory project.file('run')
            property 'forge.logging.markers', 'REGISTRIES'
            property 'forge.logging.console.level', 'debug'
        }
    }
}

fancyGradle {
    patches {
        resources
        coremods
        asm
    }
}

apply from: 'gradle/resources.gradle'

clean {
    def filteredDelete = new HashSet<>()
    for (def toDelete : getDelete()) {
        for (def f : file(toDelete).listFiles()) {
            if (f.getName() != "fg_cache") {
                filteredDelete.add(f)
            }
        }
    }
    setDelete(filteredDelete)
}

license {
    ignoreFailures = true
    ext.year = Calendar.getInstance().get(Calendar.YEAR)
    ext.company = "ReadOnly Development"
    exclude '**/*.lang'
    exclude '**/*.mcmeta'
    exclude '**/*.info'
    exclude '**/*.cfg'
    
    matching(includes: ['**/lib/**/*.java']) {
        header = project.file("LICENSE-LIB-header.txt")

    }
    matching(includes: ['**/api/**/*.java']) {
        header =  project.file("LICENSE-API-header.txt")
    }
}

if (JavaVersion.current().isJava8Compatible()) {
    tasks.withType(Javadoc) {
        options {
            addStringOption('Xdoclint:none', '-quiet')
            source = sourceSets.main.allJava
        }
    }
}

def setMainManifestProps = { Manifest manifest->
    manifest.mainAttributes (
            'Maven-Artifact': "${project.group}:${project.archivesBaseName}:${project.version}",
            'Timestamp': System.currentTimeMillis(),
            'Specification-Title': 'Interstellar',
            'Specification-Vendor': 'ReadOnly Development',
            'Specification-Version': '1',
            'Implementation-Title': 'Interstellar',
            'Implementation-Version': project.version,
            'Implementation-Vendor' :'ReadOnly Development',
            'Implementation-Timestamp': new Date().format("yyyy-MM-dd'T'HH:mm:ssZ"),
            'FMLAT': 'accesstransformer.cfg',
            'Built-On-Java': "${System.getProperty('java.vm.version')} (${System.getProperty('java.vm.vendor')})",
            'Built-On': "${project.mc_version}-${project.forge_version}"
            )
}

jar {
    manifest(setMainManifestProps)
}

jar.finalizedBy('reobfJar')

task sourceJar(type: Jar, dependsOn: classes) {
    duplicatesStrategy(DuplicatesStrategy.FAIL)
    archiveClassifier.set('sources')
    archiveVersion.set("${mc_version}-${version}")
    from sourceSets.main.allSource
}

task deobfJar(type: Jar) {
    duplicatesStrategy(DuplicatesStrategy.FAIL)
    from sourceSets.main.allJava
    from sourceSets.main.output
    archiveClassifier.set('deobf')
    manifest(setMainManifestProps)
}

//task javadocJar(type: Jar, dependsOn: javadoc) {
//    duplicatesStrategy(DuplicatesStrategy.FAIL)
//    from javadoc.destinationDir
//    archiveClassifier.set('javadoc')
//}

artifacts {
    archives deobfJar
    archives sourceJar
    archives javadocJar
}

apply from: 'gradle/maven.gradle'

import net.minecraftforge.gradle.common.tasks.*

task signJar(type: SignJar, dependsOn: 'reobfJar') {
    onlyIf {
        project.hasProperty('keyStore')
    }

    keyStore = project.findProperty('keyStore')
    alias = project.findProperty('keyStoreAlias')
    storePass = project.findProperty('keyStorePass')
    keyPass = project.findProperty('keyStoreKeyPass')
    inputFile = jar.archivePath
    outputFile = jar.archivePath
}

build.dependsOn signJar